.type Seq = [h: symbol, t: Seq]

.decl token(i: number, t: symbol)
.input token(IO=file, columns="0:1", delimiter=",")

.decl tokeni(t: symbol, i: number)
tokeni(t, autoinc()) :- token(_, t).

.decl maxi(i: number)
maxi(i) :- i = max n : tokeni(_, n).

.decl sequence(s: Seq, i: number)
sequence([t, nil], i) :- maxi(i), tokeni(t, i).
sequence([t, seq], i-1) :- sequence(seq, i), tokeni(t, i-1).

.decl sequence0(s: Seq)
sequence0(s) :- sequence(s, 0).

// Maybe a .component??
//===============================================================

.type Substantive = Noun | Pronoun
.type Noun <: symbol
.type Pronoun <: symbol
.type Particle <: symbol
.type ConjugatedVerb <: symbol

.type Statement 
    = SimpleStatement {s: SubjectPhrase, v: VPhrase}
    | SequentialStatement {s: SubjectPhrase, vseq: VSequence}
    | PredicateStatement {s: SubjectPhrase, p: PredicatePhrase}


.type SubjectPhrase = SubjectPhrase {n: Substantive,
                                     p: Particle}

.type PredicatePhrase = PredicatePhrase {n: Substantive,
                                         v: ConjugatedVerb}

.type VPhrase = VerbPhrase {v: ConjugatedVerb }
              | ObjectVerbPhrase {o: Substantive,
                                  p: Particle,
                                  v: ConjugatedVerb}

.type VSequence = TePhrase {head: VPhrase,
                            next: VSequence}
                | ConjugatedPhrase {head: VPhrase,
                                    vp: VPhrase }


/*****
 * Grammatical roles
 *****/

.input particle(IO=file)
.decl particle(token: symbol)

.input pronoun(IO=file)
.decl pronoun(token: symbol)

.decl noun(token: symbol, meaning: symbol)
.input noun(IO=sqlite, dbname="sqlite.db")

.decl verb(lemma: symbol, type: symbol, meaning: symbol, ending: symbol, transivity: symbol)
.input verb(IO=sqlite, dbname="sqlite.db") // facts are read from sqlite.db file

.decl verb_conj(lemma: symbol, masu: symbol, te: symbol)
.input verb_conj(IO=sqlite, dbname="sqlite.db") // facts are read from sqlite.db file

.decl verb_masu(lemma: symbol, conjugated: symbol)
verb_masu(lemma, conjugated) :-
  verb_conj(lemma, conjugated, _).

.decl verb_stem_ending(lemma: symbol, stem: symbol, ending: symbol)
verb_stem_ending(lemma, stem, ending) :-
  verb(lemma, _, _, ending, _),
  stem = substr(lemma, 0, strlen(lemma) - 3).

.decl verb_te(lemma: symbol, conjugated: symbol)
verb_te("だ", "で").
verb_te("する", "して").
verb_te("来る", "来て").
verb_te("行く", "行って").

verb_te(lemma, cat(stem, "いて")) :-
  verb(lemma, "godan", _, _, _),
  verb_stem_ending(lemma, stem, "く").

verb_te(lemma, cat(stem, "いで")) :-
  verb(lemma, "godan", _, _, _),
  verb_stem_ending(lemma, stem, "ぐ").

verb_te(lemma, cat(stem, "って")) :-
  verb(lemma, "godan", _, _, _),
  (ending = "う"; ending = "つ"; ending = "る"),
  verb_stem_ending(lemma, stem, ending).

verb_te(lemma, cat(stem, "んで")) :-
  verb(lemma, "godan", _, _, _),
  (ending = "ぬ"; ending = "ぶ"; ending = "む"),
  verb_stem_ending(lemma, stem, ending).

verb_te(lemma, cat(stem, "して")) :-
  verb(lemma, "godan", _, _, _),
  verb_stem_ending(lemma, stem, "す").


verb_te(lemma, cat(stem, "て")) :-
  verb(lemma, "ichidan", _, _, _),
  verb_stem_ending(lemma, stem, "る").

.decl substantive(token: symbol)
substantive(token) :- noun(token, _).
substantive(token) :- pronoun(token).

/*****
 * Capturing statement components
 * ex: watashi ha gakusei desu
 ****/

.decl subject_phrase(sp: SubjectPhrase, start: number, end: number)
subject_phrase(sp, start, end) :-
  sequence([s, [sm, _]], i),
  substantive(s),
  particle(sm),
  sp = $SubjectPhrase(s, sm),
  start = i,
  end = i+2.

.decl predicate_phrase(pred: PredicatePhrase, start: number, end: number)
predicate_phrase(pred, start, end) :-
  sequence([o, [v, _]], i),
  substantive(o),
  verb_masu(_, v),
  pred = $PredicatePhrase(o, v),
  start = i,
  end = i+2.

.decl verb_phrase(vp: VPhrase, start: number, end: number)
verb_phrase(vp, start, end) :-
  sequence([v, _], i),
  verb_masu(lemma, v),
  verb(lemma, _, _, _, "vi"),
  vp = $VerbPhrase(v),
  start = i,
  end = i+1.

verb_phrase(vp, start, end) :-
  sequence([o, [p, [v, _]]], i),
  substantive(o),
  particle(p),
  verb_masu(lemma, v),
  verb(lemma, _, _, _, "vt"),
  vp = $ObjectVerbPhrase(o, p, v),
  start = i,
  end = i + 3.

.decl verb_te_phrase(vp: VPhrase, start: number, end: number)
verb_te_phrase(vp, start, end) :-
  sequence([v, _], i),
  verb_te(vi, v),
  verb(vi, _, _, _, "vi"),
  vp = $VerbPhrase(v),
  start = i,
  end = i+1.

.decl object_verb_te_phrase(ovp: VPhrase, start: number, end: number)
object_verb_te_phrase(ovp, start, end) :-
  sequence([o, [p, [v, _]]], i),
  substantive(o),
  particle(p),
  verb_te(vt, v),
  verb(vt, _, _, _, "vt"),
  ovp = $ObjectVerbPhrase(o, p, v),
  start = i,
  end = i + 3.

.decl te_phrase(phrase: VPhrase, start: number, end: number)
te_phrase(phrase, start, end) :-
  (verb_te_phrase(phrase, start, end); object_verb_te_phrase(phrase, start, end)).


.decl verb_sequence(vseq: VSequence, start: number, end: number)
verb_sequence(vseq, start, end) :-
  te_phrase(tp, start, end1),
  verb_phrase(vp, end1, end),
  
  vseq = $ConjugatedPhrase(tp, vp).

verb_sequence(vseq, start, end) :-
  te_phrase(head, start, end1),
  verb_sequence(next, end1, end),
  vseq = $TePhrase(head, next).

.decl statement(st: Statement)
statement(st) :-
  subject_phrase(s, _, end),
  predicate_phrase(p, end, _),
  st = $PredicateStatement(s, p).

statement(st) :-
  subject_phrase(s, _, end1),
  verb_phrase(v, end1, _),
  st = $SimpleStatement(s, v).

statement(st) :-
  subject_phrase(s, _, end1),
  verb_sequence(vseq, end1, _),
  st = $SequentialStatement(s, vseq).

.decl debug(vp: VPhrase, start: number, end: number)
debug(vp, start, end) :-
  sequence([o, [p, [v, _]]], i),
  substantive(o),
  particle(p),
  verb_masu(lemma, v),
  verb(lemma, _, _, _, _),
  vp = $ObjectVerbPhrase(o,p,v),
  start = i,
  end = i+3.

.output token
.output statement
